<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Release It 读书笔记 - Stability patterns (part2) - ryji's personal blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="ryji"><meta name=description content="本文为 Release It! 第五章笔记的第二部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><meta name=keywords content="ryji,code,tracing,big-data"><meta name=generator content="Hugo 0.79.1 with theme even"><link rel=canonical href=http://ryji.github.io/post/release_it/stability_pattern_part2/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Release It 读书笔记 - Stability patterns (part2)"><meta property="og:description" content="本文为 Release It! 第五章笔记的第二部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><meta property="og:type" content="article"><meta property="og:url" content="http://ryji.github.io/post/release_it/stability_pattern_part2/"><meta property="article:published_time" content="2021-03-27T10:16:33+08:00"><meta property="article:modified_time" content="2022-05-04T18:19:17+08:00"><meta itemprop=name content="Release It 读书笔记 - Stability patterns (part2)"><meta itemprop=description content="本文为 Release It! 第五章笔记的第二部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><meta itemprop=datePublished content="2021-03-27T10:16:33+08:00"><meta itemprop=dateModified content="2022-05-04T18:19:17+08:00"><meta itemprop=wordCount content="2333"><meta itemprop=keywords content="stability,design,pattern,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Release It 读书笔记 - Stability patterns (part2)"><meta name=twitter:description content="本文为 Release It! 第五章笔记的第二部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>ryji's blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>ryji's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Release It 读书笔记 - Stability patterns (part2)</h1><div class=post-meta><span class=post-time>2021-03-27</span><div class=post-category><a href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a>
<a href=/categories/release-it/>Release It</a></div><span class=more-meta>约 2333 字</span>
<span class=more-meta>预计阅读 5 分钟</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#steady-state-稳态>Steady State (稳态)</a><ul><li><a href=#数据清洗>数据清洗</a></li><li><a href=#日志>日志</a></li><li><a href=#内存中的cache>内存中的cache</a></li></ul></li><li><a href=#handshaking-shed-loadcreate-back-pressure>Handshaking ，Shed Load，Create Back Pressure</a><ul><li><a href=#handshaking-握手>Handshaking (握手)</a></li><li><a href=#shed-load-丢弃负载>Shed Load (丢弃负载)</a></li><li><a href=#create-back-pressure-背压>Create Back Pressure (背压)</a></li></ul></li><li><a href=#test-harnesses-测试套件>Test Harnesses (测试套件)</a></li><li><a href=#decoupling-middleware-中间件解耦>Decoupling Middleware (中间件解耦)</a></li><li><a href=#governor-调节器>Governor (调节器)</a></li></ul></li></ul></nav></div></div><div class=post-content><p>本文为 Release It! 第五章笔记的第二部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系统出错导致全部服务出错的可能。</p><h2 id=steady-state-稳态>Steady State (稳态)</h2><p>运维/开发人员对生产/测试/开发环境中服务器配置的修改会导致系统处于不稳定的状态。通过流程自动化，在减少/消除人为干预的前提下，完成产品的发布，避免人员错误导致的系统风险。</p><p>随着系统的运行，数据库中的记录条数、缓存对内存的占用、日志数量都会不断增多。Steady State 指的是，必须有对应的手段减少这些随着系统运行不断累计增多的资源，将系统保持在一个比较稳定的状态。</p><h3 id=数据清洗>数据清洗</h3><p>随着系统的运行，数据库中的数据会逐渐增长，数据库服务器 IO 占用不断增高导致系统变慢。除了分库分表外，还可以将数据分为热数据和冷数据，两者采用不同的存储方案。</p><p>开发人员需要保持热数据所在的数据库中的记录数量稳定，且数据清洗过程不会导致应用出错。</p><h3 id=日志>日志</h3><p>如果日志需要保存在服务器(第三方组件、遗留代码)上，那么最好使用类似 Kafka 的循环日志记法(限制日志的保存时间或磁盘占用空间，使用 logrotate 工具可以很方便地实现这个功能)。</p><p>新的应用，特别是使用容器化部署方式的应用，最好采用集中化的日志存储方案。所有服务通过 Logstash 等组件将日志集中在同一个地方，建立索引后供开发/运维人员检索。</p><h3 id=内存中的cache>内存中的cache</h3><p>建立缓存时，需要考虑两个问题：1.key 的数量是否有上限；2.缓存的数据是否会被更改。如果缓存的 item 数量无上限，那么必须限制缓存的数量或者缓存占用的内存。如果缓存的数据需要进行修改，那么必须限制缓存的生效时间，或者采用定时刷新缓存的方案。</p><p><strong>总结</strong></p><ul><li>避免/减少人为干预</li><li>结合业务逻辑进行数据清洗</li><li>清理日志</li><li>限制缓存对内存的占用</li></ul><h2 id=handshaking-shed-loadcreate-back-pressure>Handshaking ，Shed Load，Create Back Pressure</h2><p>服务器应能够保护自己，限制(throttling)自身承载的工作负载。</p><h3 id=handshaking-握手>Handshaking (握手)</h3><p>在底层通信协议(RS232, TCP)中，handshaking 应用得比较广泛，可以让接收端通知发送端停止发送数据，直到接收端准备完毕。但是在 HTTP 等应用层协议中，handshaking 未被充分利用，导致 Cascading Failures。</p><p>通过在服务中加入 health check，负载均衡组件能够获取服务器的负载状态，避免继续对过载的服务继续转发请求。更进一步，当服务发现自身无法保障 SLA 时，可以停止 health check 的响应，这样负载均衡组件就会认为服务不可用，避免服务接收到更多的请求。</p><h3 id=shed-load-丢弃负载>Shed Load (丢弃负载)</h3><p>与 handshaking 相似，shed load 描述的是将系统无法承载的请求丢掉来降低系统负载的方案。通常可以结合SLA，限制系统并发请求的数量来丢弃过多的请求。</p><h3 id=create-back-pressure-背压>Create Back Pressure (背压)</h3><p>在使用异步调用机制时，如果上游生产消息的速度大于下游消费消息的速度，就会导致消息在队列中的堆积，新产生的消息迟迟无法得到处理，在外部看来，就好像是消费者已经挂掉一样。</p><p>在这种情况下，一方面可以对队列中的消息进行监控，及时发现此类问题；另一方面，由于消费者的消费能力有限，可以通过背压调节生产者的生产速度，阻止生产者过快地生产消息。</p><p>背压的调节机制往往会导致线程阻塞。因此，系统一般使用一个线程池接受请求，另一个线程池处理请求。当处理请求的线程因背压而阻塞时，接受请求的线程会因超时而返回错误。</p><p>在系统的边界处，如果使用背压，调用方的线程可能会阻塞，导致调用方挂掉。因此，在系统边界处，一般使用 shed load 模式或者异步调用机制来保护服务的调用方。</p><p><strong>总结</strong></p><ul><li>建立协作式的请求/响应控制</li><li>使用 health check</li><li>使用负载均衡获取服务状态</li><li>自定义的底层协议增加 Handshaking 机制</li><li>在系统内部使用背压传递压力，跨越系统边界时使用 shed load</li></ul><h2 id=test-harnesses-测试套件>Test Harnesses (测试套件)</h2><p>因为负载和网络环境的差异，QA 环境中往往无法提前发现生产环境的问题。大部分 QA 只是在系统的所有依赖项运行良好的情况下，测试功能是否正常。更好的手段是，通过导致系统失败的模式来进行测试。因此，需要使用测试套件来模拟远端系统，建立异常列表，对系统的质量进行测试。</p><p>因对远端的请求是网络请求，其 socket 连接可能会受如下因素导致失败：</p><ul><li>连接被拒绝</li><li>连接被放入 listen queue 中，直到 timeout</li><li>远端发送 SYN/ACK 之后，不发送数据</li><li>远端只发送 RESET</li><li>远端声明 receive window 已满，无法再发送数据，</li><li>连接建立后，始终不发送数据</li><li>连接建立后，存在丢包导致重传</li><li>连接建立后，远端永远不返回ACK，导致无限重传</li><li>HTTP 服务端接收请求后，返回 http header 之后，不返回 http body</li><li>服务返回数据非常慢(1 byte per 30 seconds)</li><li>服务返回的数据类型与约定不一致(HTML VS XML)</li><li>服务返回的数据大小与预期不符 (MB VS KB)</li><li>服务拒绝所有的证书</li></ul><p>测试套件可以在服务中注入诸如此类的错误，进一步发掘服务之间的依赖项。混沌工程(chaos engineering)是使用此模式的一种方案。</p><p><strong>总结</strong></p><ul><li>模拟未在文档中声明的错误</li><li>给服务的调用方增加压力</li><li>test harness 是其它测试方法的补充，无法取代其它测试方法的作用</li></ul><h2 id=decoupling-middleware-中间件解耦>Decoupling Middleware (中间件解耦)</h2><p>RPC、HTTP都属于同步调用方案(sync call-response, request-reply)，其优点为逻辑简单，缺点为两个系统之间紧耦合，两个系统必须同时处于可用状态才能请求成功。</p><p>基于队列的 MQ 或者 publish/subscribe 的消息组件时一种松耦合方案，它不要求两个系统同时处于可用状态，可以防止系统出现 Cascading Failures。松耦合的方案在请求方需要获取服务提供方的返回值时，往往需要更复杂的设计方案。</p><p><strong>总结</strong></p><ul><li>尽早决定是否采用中间件进行解耦</li><li>完全解耦能够避免很多导致系统失败的模式</li><li>学习更多的架构方案</li></ul><h2 id=governor-调节器>Governor (调节器)</h2><p>流程自动化/控制面出现错误时，对整个系统的破坏力是巨大的。因此，对某些有风险的自动操作(关闭节点，删除数据，block ip)，需要降低控制面的处理速度，或者引入人工确认环节，降低风险。</p><p><strong>总结</strong></p><ul><li>增加流程的阻力，降低速度，允许人为介入</li><li>在有风险的操作中，引入人工确认</li><li>建立风险曲线，短时间的大量低风险的操作也可能引入高风险(短时间大量创建节点)</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>ryji</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2022-05-04
<a href=https://github.com/ryji/ryji.github.io.git/commit/a0b802eb22ad2335267ea622efd071e9eae9181f title="move dir">(a0b802e)</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/stability/>stability</a>
<a href=/tags/design/>design</a>
<a href=/tags/pattern/>pattern</a></div><nav class=post-nav><a class=prev href=/post/csharp/orleans/transaction/orleans_transaction_causalclock/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Causal Clock</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/release_it/stability_pattern_part1/><span class="next-text nav-default">Release It 读书笔记 - Stability patterns (part1)</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:ruoyangji@163.com class="iconfont icon-email" title=email></a><a href=https://github.com/ryji/ class="iconfont icon-github" title=github></a><a href=http://ryji.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>ryji</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],}};</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>