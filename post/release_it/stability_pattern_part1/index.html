<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Release It 读书笔记 - Stability patterns (part1) - ryji's personal blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="ryji"><meta name=description content="本文为 Release It! 第五章笔记的第一部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><meta name=keywords content="ryji,code,tracing,big-data"><meta name=generator content="Hugo 0.79.1 with theme even"><link rel=canonical href=http://ryji.github.io/post/release_it/stability_pattern_part1/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Release It 读书笔记 - Stability patterns (part1)"><meta property="og:description" content="本文为 Release It! 第五章笔记的第一部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><meta property="og:type" content="article"><meta property="og:url" content="http://ryji.github.io/post/release_it/stability_pattern_part1/"><meta property="article:published_time" content="2021-03-21T20:45:59+08:00"><meta property="article:modified_time" content="2022-05-04T21:41:42+08:00"><meta itemprop=name content="Release It 读书笔记 - Stability patterns (part1)"><meta itemprop=description content="本文为 Release It! 第五章笔记的第一部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><meta itemprop=datePublished content="2021-03-21T20:45:59+08:00"><meta itemprop=dateModified content="2022-05-04T21:41:42+08:00"><meta itemprop=wordCount content="2638"><meta itemprop=keywords content="stability,design,pattern,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Release It 读书笔记 - Stability patterns (part1)"><meta name=twitter:description content="本文为 Release It! 第五章笔记的第一部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>ryji's blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>ryji's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Release It 读书笔记 - Stability patterns (part1)</h1><div class=post-meta><span class=post-time>2021-03-21</span><div class=post-category><a href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a>
<a href=/categories/release-it/>Release It</a></div><span class=more-meta>约 2638 字</span>
<span class=more-meta>预计阅读 6 分钟</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#timeout-超时时间>Timeout (超时时间)</a></li><li><a href=#circuit-breaker-断路保护器>Circuit Breaker (断路保护器)</a></li><li><a href=#bulkheads-隔离仓>Bulkheads (隔离仓)</a></li><li><a href=#fail-fast-快速失败>Fail Fast (快速失败)</a></li><li><a href=#let-it-crash-让它崩溃>Let It Crash (让它崩溃)</a><ul><li><a href=#限制粒度>限制粒度</a></li><li><a href=#快速替换>快速替换</a></li><li><a href=#监督管理>监督管理</a></li><li><a href=#再整合>再整合</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><p>本文为 Release It! 第五章笔记的第一部分，主要介绍服务/应用设计中可以提高系统可用性的模式 (patterns)。这些模式可以降低、减缓或者消除因局部系统出错导致全部服务出错的可能。</p><h2 id=timeout-超时时间>Timeout (超时时间)</h2><p>在进行网络请求时，设置超时时间是很常见的。然而，在系统集成时，第三方的 API 往往不会提供超时时间参数供使用者调用。这时需要采用 timeout 模式调用这些 API，避免因第三方系统的问题导致服务崩溃。</p><p>另外，即使在一个系统内部，也会有需要设置超时时间的场景。例如，访问资源池时，访问线程可能会被 block，这时，如果采用 timeout 模式，这些被 block 的线程会在达到超时时间后返回，防止大多数线程被同一个资源阻塞，导致系统无线程可用。另外，使用同步或者信号量原语时，最好也增加 timeout 参数，避免无限制的等待。</p><p>另外，在过去的经验中，超时往往会和重试在一起使用。在使用重试时，除了瞬态错误外(丢包)，大部分错误(配置出错，服务出错)都无法通过重试恢复。在 GUI 编程中，因进行重试而阻塞 UI 界面会降低用户体验。在部分场景中，将任务排入队列，在稍晚的时间进行重试也可能会提高系统的鲁棒性。总之，在使用重试时，需要仔细考虑业务要求和错误类型。</p><p>timeout 模式和 Fail Fast 模式一体两面，前者用于处理 outbound requests，后者用来处理 incoming requests。</p><p><strong>总结</strong></p><ul><li>在系统集成点、阻塞线程和资源池访问时使用 timeout</li><li>使用 timeout 从异常中恢复</li><li>考虑延迟后进行重试</li></ul><h2 id=circuit-breaker-断路保护器>Circuit Breaker (断路保护器)</h2><p>断路保护器来源于电气学科，共包含三种状态：Closed、Open、Half-Open。断路保护器会代理被保护的请求，并通过统计请求成功/失败的频次来调整自身的状态。如图所示。</p><p><img src=circute_breaker.jpg alt=breaker></p><ul><li>状态为 Closed 时，所有的请求都会被转发到实际的服务中，如果请求成功，返回请求结果；如果请求失败，失败频次累加，当失败频次达到上限，则断路保护器会转移到 Open 状态。</li><li>当保护器状态为 Open 时，所有的请求都立即返回失败。状态为 Open 的断路保护器经过一定的超时时间后，状态转移到 Half-Open。</li><li>状态为 Half-Open 的断路保护器会尝试转发一部分请求(一般为一个)到实际的服务中，如果成功，断路保护器转移到 Closed，失败则转移到 Open。</li></ul><p>断路保护器也用于处理 outbound requests，它提供了一种自动降级的机制：当系统需要的资源不可用时，不再对其进行频繁访问。在断路保护器状态为 Open 时，往往需要使用 fallback 进行处理。</p><p>对于系统运维来说，断路保护器的状态非常重要。因此，使用此模式时，需要将其状态转移记录日志，将其状态(Closed、Open、Half-Open)暴露到运维终端。另外，还需要提供一种在外部控制保护器状态的方法，运维人员可根据系统运行状态手工控制保护器的开关，避免保护器参数设置不合理导致的系统崩溃。</p><p><strong>总结</strong></p><ul><li>如果系统不可用，停止调用此系统</li><li>和 timeout 配合使用</li><li>暴露、追踪、报告断路保护器的状态</li></ul><h2 id=bulkheads-隔离仓>Bulkheads (隔离仓)</h2><p>bulkhead 来源于海运，原为当船只进水时，将船分割成多个小单元，防止水淹没整只船的隔舱。在设计软件系统时，也可以应用相似的思路，将失败的子系统与正常子系统隔离，防止整个系统失败。</p><p>从程序运行的环境来说，可用的 bulkhead 方式是物理冗余：即使部分实例失败，也不会影响其余实例的运行。除了物理机、虚拟机的冗余外，当使用FAAS(functions as a service)时，实际上每次调用都在不同的环境中运行，这也是一种 bulkhead 的方式。</p><p>从服务编排的角度来说，将公共服务的实例划分为不同的实例池，供不同的服务调用时另一种实现 bulkhead 的方式。这样，即使某一个服务过载，导致其对应的公共服务池崩溃，也不会影响其它服务和他们对应的公共服务池的使用。</p><p>从(容器)来说，容器初始化时，往往制定其使用的CPU/memory上限。即使某一容器发生内存泄漏，也不会将整个系统的可用内存耗尽，不会影响其它容器的创建和运行。</p><p>从服务内部来说，bulkhead 是将线程池等资源划分，不同的服务/业务使用不同的线程池。这样，即使某一业务线程资源耗尽，也不会影响其它部分接受请求。这样也可以帮助服务保留供 admin 用户使用的资源(管理服务状态、日志、trace 等)</p><p><strong>总结</strong></p><ul><li>保护整个系统</li><li>选择合理的隔离尺度(应用中的线程池、服务器上的CPU、集群中的服务)</li><li>使用 SOA 或者微服务架构时，考虑bulkhead</li></ul><h2 id=fail-fast-快速失败>Fail Fast (快速失败)</h2><p>如果系统可以预先确定操作会失败，那么可以使用 fail fast 模式来防止系统进行一段时间的处理后再返回错误消息。</p><p>负载均衡组件或者服务网关组件可以在服务不可用时，直接返回错误消息。错误的配置会导致请求不会立刻返回，而是在这些组件中等待一段时间，但是等待期间，目标服务往往无法恢复。</p><p>当应用处于繁忙状态无法再处理新的请求时，可以立即返回失败消息。</p><p>另外，对用户的输入进行检查，也是 Fail Fast 模式的一种实现。用户的输入不合法或者用户的客户端资源不足(磁盘/内存)时，可以立即返回异常信息，让用户进行处理。</p><p>使用 Fail Fast 模式时，要注意区分资源耗尽和用户输入的异常，防止用户输入不合法触发上游的断路保护器。</p><p><strong>总结</strong></p><ul><li>避免慢响应</li><li>预先检查资源占用情况</li><li>校验用户输入</li></ul><h2 id=let-it-crash-让它崩溃>Let It Crash (让它崩溃)</h2><p>当发生无法/很难恢复的错误时，让出现错误的组件崩溃往往是唯一的选择。为了能够应用 let it crash 模式，需要满足如下条件：</p><h3 id=限制粒度>限制粒度</h3><p>崩溃部分必须有可控的边界。其它与之有关联的系统必须能够保护自身，不会因崩溃部分而崩溃。</p><h3 id=快速替换>快速替换</h3><p>实例崩溃后，必须能够快速创建其替代品。</p><p>当使用容器时，整个容器的启动时间往往在毫秒到秒级别，此时可以直接让容器 crash 并创建新的容器。</p><p>当使用虚拟机时且进程启动时间为秒级别时，由于虚拟机的启动时间往往在分钟级别，此时最好是让虚拟机上运行的进程 crash。</p><p>当服务进程的启动时间是分钟级别时，最好不要使用 let it crash 模式，而应该尽量从错误中恢复。</p><h3 id=监督管理>监督管理</h3><p>当错误出现时，该组件的管理单元可以让该组件崩溃并重启一个新的组件。如果错误持续频繁出现，此时可能是因为管理单元内部的状态出现了问题，最好将此管理单元 crash，并重新创建此管理单元。监督管理单元按层级结构划分，直至到进程的根节点。</p><p>需要注意的是，autoscaling 组件和这里的监督管理组件有所不同。autoscaling 总是会重启崩溃的实例，而且autoscaling 组件没有方向性，也没有层次结构。</p><h3 id=再整合>再整合</h3><p>let it crash 实施的必要条件时，系统的其余部分能够在创建新的崩溃组件实例后获得通知，并且能够使用此组件。如果崩溃的是一个服务，那么在此启动的服务需要能够注册到服务发现组件中，这样负载均衡组件才能将请求分配过来。</p><p><strong>总结</strong></p><ul><li>为了保护系统，可以让组件崩溃</li><li>快速启动并整合资源</li><li>隔离崩溃的组件</li><li>不要让单体应用崩溃</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>ryji</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2022-05-04
<a href=https://github.com/ryji/ryji.github.io.git/commit/f104b135c3183d53db0bb3d1953e8bacd92964ce title="modify gitignore">(f104b13)</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/stability/>stability</a>
<a href=/tags/design/>design</a>
<a href=/tags/pattern/>pattern</a></div><nav class=post-nav><a class=prev href=/post/release_it/stability_pattern_part2/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Release It 读书笔记 - Stability patterns (part2)</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/kafka/kafka_basic_intro/><span class="next-text nav-default">Kafka basic intro</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:ruoyangji@163.com class="iconfont icon-email" title=email></a><a href=https://github.com/ryji/ class="iconfont icon-github" title=github></a><a href=http://ryji.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>ryji</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],}};</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>