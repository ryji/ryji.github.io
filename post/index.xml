<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on My New Hugo Site</title><link>http://example.org/post/</link><description>Recent content in Posts on My New Hugo Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 05 Mar 2018 05:43:58 +0800</lastBuildDate><atom:link href="http://example.org/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Template in C#</title><link>http://example.org/post/template_in_csharp/</link><pubDate>Mon, 05 Mar 2018 05:43:58 +0800</pubDate><guid>http://example.org/post/template_in_csharp/</guid><description>泛型（参数化类型），将程序逻辑从具体的类型中分离出来，从而提高代码的复用性。 .Net的System.Collections.Generic命名空间中定义的大多数类型使用了泛型技术，比如List&amp;lt;T&amp;gt;，Stack&amp;lt;T&amp;gt;，Tuple&amp;lt;T1, T2, T3, ...&amp;gt;，SortedList&amp;lt;TKey, TValue&amp;gt;等，另外，委托类型也提供了泛型委托Action和Function。泛型接口定义了一种参数化类型的接口，保障程序的类型安全。
泛型树节点接口 以树的遍历为例，不管树节点的类型和实现是什么，只要知道当前节点的深度和其子节点，就可以进行树的遍历。因此，定义泛型树节点接口ITreeNode&amp;lt;T&amp;gt;。
public interface ITreeNode&amp;lt;T&amp;gt; where T : class { int Depth { get; set; } //深度 List&amp;lt;T&amp;gt; GetChildren(); //获取子节点 } 泛型树的约束 在泛型树的定义中添加约束class和ITreeNode&amp;lt;T&amp;gt;，这样，在编译期就可以确保类型安全，用未实现ITreeNode&amp;lt;T&amp;gt;接口的class来实例化Tree&amp;lt;T&amp;gt;时会编译出错。
public class Tree&amp;lt;T&amp;gt; where T : class, ITreeNode&amp;lt;T&amp;gt; { //树根 public T Root { get; set; } //最大深度 public int MaxDepth { get; set; } public void Travel() { Travel(Root, MaxDepth); } public void Travel(int maxDepth) { Debug.Assert(maxDepth &amp;gt;= 0); Travel(Root, Math.</description></item></channel></rss>