<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>High-Performance Browser Networking 读书笔记-TLS - ryji's personal blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="ryji"><meta name=description content="引言 TLS (Transport Layer Security)建立在传输层之上，为其它协议提供跨网络的安全传输能力，这种能力包含三个部分：加密、认证、防篡改和伪造。TLS通过"><meta name=keywords content="ryji,code,tracing,big-data"><meta name=generator content="Hugo 0.79.1 with theme even"><link rel=canonical href=http://ryji.github.io/post/hpbn-tls/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="High-Performance Browser Networking 读书笔记-TLS"><meta property="og:description" content="引言 TLS (Transport Layer Security)建立在传输层之上，为其它协议提供跨网络的安全传输能力，这种能力包含三个部分：加密、认证、防篡改和伪造。TLS通过"><meta property="og:type" content="article"><meta property="og:url" content="http://ryji.github.io/post/hpbn-tls/"><meta property="article:published_time" content="2021-02-13T15:19:53+08:00"><meta property="article:modified_time" content="2021-02-14T10:03:28+08:00"><meta itemprop=name content="High-Performance Browser Networking 读书笔记-TLS"><meta itemprop=description content="引言 TLS (Transport Layer Security)建立在传输层之上，为其它协议提供跨网络的安全传输能力，这种能力包含三个部分：加密、认证、防篡改和伪造。TLS通过"><meta itemprop=datePublished content="2021-02-13T15:19:53+08:00"><meta itemprop=dateModified content="2021-02-14T10:03:28+08:00"><meta itemprop=wordCount content="3534"><meta itemprop=keywords content="TLS,network,"><meta name=twitter:card content="summary"><meta name=twitter:title content="High-Performance Browser Networking 读书笔记-TLS"><meta name=twitter:description content="引言 TLS (Transport Layer Security)建立在传输层之上，为其它协议提供跨网络的安全传输能力，这种能力包含三个部分：加密、认证、防篡改和伪造。TLS通过"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>ryji's blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>ryji's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>High-Performance Browser Networking 读书笔记-TLS</h1><div class=post-meta><span class=post-time>2021-02-13</span><div class=post-category><a href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></div><span class=more-meta>约 3534 字</span>
<span class=more-meta>预计阅读 8 分钟</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#tls握手>TLS握手</a><ul><li><a href=#协议扩展>协议扩展</a></li></ul></li><li><a href=#tls-session重用>TLS Session重用</a><ul><li><a href=#tls-session-id>TLS Session Id</a></li><li><a href=#tls-session-ticket>TLS Session Ticket</a></li></ul></li><li><a href=#证书废止>证书废止</a></li><li><a href=#tls优化>TLS优化</a><ul><li><a href=#计算负载>计算负载</a></li><li><a href=#及早终止>及早终止</a></li><li><a href=#tls-session重用-1>TLS Session重用</a></li><li><a href=#tls数据大小>TLS数据大小</a></li><li><a href=#tls压缩>TLS压缩</a></li><li><a href=#证书链的长度>证书链的长度</a></li><li><a href=#ocsp-stapling>OCSP Stapling</a></li><li><a href=#hsts-http-strict-transport-security>HSTS (HTTP Strict Transport Security)</a></li></ul></li><li><a href=#checklist>Checklist</a></li></ul></nav></div></div><div class=post-content><h1 id=引言>引言</h1><p>TLS (Transport Layer Security)建立在传输层之上，为其它协议提供跨网络的安全传输能力，这种能力包含三个部分：加密、认证、防篡改和伪造。TLS通过非对称加密技术，在非加密信道中，为无先验信息的通信双方提供协商会话秘钥(对称秘钥)的方法；在TLS握手过程中，协议规定了一系列认证方法，使通信双方能够互相认证；最后，TLS提供消息校验码(message authentication code，MAC)来对每一条传输的消息进行校验，防止传输途中的篡改和伪造。</p><p>HTTP协议的成功，催生出很多网络中间件：缓存服务器、安全网关、内容过滤器等。基于HTTP协议的新协议可能无法被这种中间件识别，或者会被这些中间件盲目地篡改。因此，在WebSocket协议中，一般会推荐使用HTTPS作为其通信的信道，这样防止消息被中间件篡改。</p><h1 id=tls握手>TLS握手</h1><p>TLS协议握手过程如下图所示：</p><table><thead><tr><th>时刻</th><th>事件</th></tr></thead><tbody><tr><td>0 ms</td><td>建立TCP信道</td></tr><tr><td>56 ms</td><td>客户端发送其支持的TLS信息，包括版本，支持的加密组件列表，随机数rand_c</td></tr><tr><td>84 ms</td><td>服务端根据客户端发送的信息，选择一种加密组件，附带服务端的证书和随机数rand_s，发送到客户端</td></tr><tr><td>112 ms</td><td>如果双方对版本和加密方式达成一致，且服务端的证书在客户端认证通过。客户端生成一个对称秘钥key，使用服务端的公钥加密后的发送到服务端，并通知服务端切换到加密传输模式</td></tr><tr><td>140 ms</td><td>服务端使用私钥解密客户端发送的对称秘钥key，并通过消息的MAC校验消息的完整性。基于对称秘钥key, rand_c, rand_s计算出随后与客户端通信使用的秘钥，并基于此秘钥发送加密的finish消息</td></tr><tr><td>168 ms</td><td>客户端基于对称秘钥key, rand_c, rand_s计算出对称秘钥，使用此秘钥解密服务端的消息。至此，加密通信信道完全建立</td></tr></tbody></table><p><img src=image-20210213155746129.png alt=image-20210213155746129></p><h2 id=协议扩展>协议扩展</h2><ul><li>ALPN（Application Layer Protocol Negotiation）</li></ul><p>使用自定义协议时，通信的双方需要进行协商，例如http协议升级到2.0。使用ALPN技术，可以利用现有的TLS 443端口协商服务协议，其过程为：客户端在ClientHello消息中增加<code>ProtocolNameList</code>字段，其值为客户端支持的协议列表，服务端读取<code>ProtocolNameList</code>后，根据自身支持的协议，在ServerHello消息中，增加<code>ProtocolName</code>字段，其值为服务端选定的自定义协议。</p><ul><li>SNI(server Name Indication)</li></ul><p>同一个IP地址host多个不同的服务，每个服务都有各自的TLS证书</p><h1 id=tls-session重用>TLS Session重用</h1><p>完整的TLS握手流程会给应用程序造成比较大的延时，因此，人们提出了一些重用已经建立的TLS会话的方法来降低因安全导致的性能损失。</p><h2 id=tls-session-id>TLS Session Id</h2><p>服务端可以在ServerHello消息中包含一个32字节的Session Id，如果客户端和服务端都将这个ID存储在缓存中，那么在接下来的TLS握手中，客户端可以在ClientHello消息中包含此ID，这样服务端就可以判断客户端是在重用已建立好的TLS会话，这样提高应用性能。例如，虽然浏览器会与同一个服务端建立多个连接来并行请求资源，但只有第一个连接进行了完整的TLS握手流程，其它连接会等待第一个TLS握手建立完毕后，重用其TLS Session Id</p><p><img src=image-20210213201753900.png alt=image-20210213201753900></p><p>但这个方案会导致服务器需要创建并维护每一个客户端的TLS session缓存，对于访问量比较大的应用来说，每台服务器可能每天需要创建上百万条TLS session缓存，这会给服务器带来巨大的内存消耗。虽然可以在外部引入缓存服务器来存储这些缓存，但这也会增加运维的难度和成本。</p><h2 id=tls-session-ticket>TLS Session Ticket</h2><p>Session Ticket解决了服务端必须缓存TLS sesssion的问题。在一次完整的TLS握手过程中，服务端发送给客户端一个ticket，这个ticket使用一个服务端的私钥进行加密。客户端在后续的clientHello消息中，可以在<code>SessionTicket</code>字段中加入此ticket。因为ticket使用服务端的私钥进行加密，因此，无法再传输过程中被篡改和伪造。相对于Session Id的方案，此方案的服务端是无状态的。</p><p>在实践中，部署负载均衡的TLS Session Ticket服务也需要进行谨慎的规划，所有隐藏在负载均衡器后面的服务器必须使用相同的私钥，或者周期性地在服务器间同步使用的私钥。</p><h1 id=证书废止>证书废止</h1><ul><li>CRL(Certificate Revocation List)</li></ul><p>CA厂商维护一个废止列表，浏览器请求获取此列表，缓存此列表，在认证时查询证书是否已作废。这种方式的问题有：客户端缓存无法及时失效；废止列表慢慢变大后的带宽消耗。</p><ul><li>OCSP(Online Certificate Status Protocol)</li></ul><p>实时查询CA证书库，通过证书序列号获取证书状态。因此，CA厂商需要支持实时查询的负载，需要保证服务全球可用；进行实时查询时，认证过程被阻塞；存在泄漏客户访问地址到CA厂商的隐私风险。</p><p>实际中，这两种废除证书的方式是共存的。</p><h1 id=tls优化>TLS优化</h1><h2 id=计算负载>计算负载</h2><p>根据谷歌和facebook的实践经验，TLS计算占据不到1%的CPU负载，而且在现代硬件上，其计算速度足够快，不需要进行过多的优化。</p><h2 id=及早终止>及早终止</h2><p>在最坏的情况下，一次完整的TLS握手过程需要消耗3倍回环时间。因此，一个优化方式是及早终止TLS握手过程：在靠近客户端的区域部署本地服务器。这些本地服务器可以与实际执行业务的服务器建立长连接会话池，并将发送到本地服务器的请求代理到原始服务器上，这样来提高应用性能。</p><p><img src=image-20210213212711611.png alt=image-20210213212711611></p><h2 id=tls-session重用-1>TLS Session重用</h2><p>在使用Session Cache作为Session重用的技术时，需要注意如下几点：</p><ul><li>多进程服务应共享session</li><li>session cache的大小应与应用访问量匹配</li><li>session超时时间需进行配置</li><li>多服务器环境中，路由同一个IP或者同一个TLS Session Id到同一个服务器</li><li>在负载均衡环境中，使用外部共享缓存存储session</li><li>检查缓存命中统计数据</li></ul><p>在使用Session ticket作用Session重用技术时，由于不是所有的客户端都支持此技术，因此，通常需要同时实现基于cache和ticket两种方案，将cache方案作为fallback</p><h2 id=tls数据大小>TLS数据大小</h2><p>每个TLS数据包中有20-40 byte用来存放header，MAC和其它内容。如果数据包的体积过大，那么这个数据包可能会超过MTU(典型值为1500 byte)，这是TLS数据包会被分成若干个packet在TCP/IP协议层传递，就有可能会因HOL问题产生较大的延时。如果数据包过小，其header导致的性能损耗比例相对提升。一种优化TLS数据包大小的方法是：在单个TLS包不超过MTU的前提下，包中包含的数据要尽可能多。</p><p>例如，在MTU为1500 byte的环境中，分配IP层header为20 byte (40 byte for IPV6)，分配TCP framing 20 byte，分配TCP可选项40 byte，这样 TLS包的大小应为1420 byte。</p><h2 id=tls压缩>TLS压缩</h2><p>TLS虽然支持压缩，但由于以下原因，不应再实际中使用</p><ul><li>“CRIME”攻击</li><li>TLS压缩不区分内容，会对已经压缩过得内容再次进行压缩，浪费CPU资源。</li></ul><p>内容的压缩不应依赖于TLS压缩，相反，应在web服务器配置文本资源的GZip压缩，而音频/视频/图像应各自采用优化的压缩算法</p><h2 id=证书链的长度>证书链的长度</h2><p>浏览器认证时，从网站的证书开始向父节点遍历，直到根证书。因此，一个重要的优化是，在TLS握手返回结果中，包含所有需要认证的证书。虽然浏览器自身也可以获取这些中间证书，但这意味着认证暂停、DNS查询、TCP连接等待一系列耗时的行为</p><p>另外，在证书链中排除不必要的证书。在理想条件下，发送到浏览器的证书应该只有两个：网站的证书和CA的证书。根证书是不必要的：如果浏览器中包含此根证书，那么网站是可信的；如果浏览器中不包含此根证书，那么及时发送根证书到浏览器，网站依然是不可信的。</p><h2 id=ocsp-stapling>OCSP Stapling</h2><p>前面提到浏览器端的OCSP会导致认证过程阻塞。OCSP Stapling允许服务端在发送证书链时，附带上OCSP response到浏览器。服务端可以缓存本服务证书OCSP response，避免客户端的多余请求。使用此方案时，需要考虑如下问题：</p><ul><li>OCSP response大小为400 byte - 4000 byte，可能会导致TLS数据包超过<code>cwnd</code></li><li>证书链中只能包含一个OCSP response，如果证书链包含较多的证书，浏览器可能仍需要进行OCSP请求。</li></ul><h2 id=hsts-http-strict-transport-security>HSTS (HTTP Strict Transport Security)</h2><p>HSTS允许服务端通过声明一个header，强制要求浏览器在随后一段时间的仅能发送HTTPS请求到此域名及子域名。HSTS可以减少网络攻击，避免不必要的HTTP请求到HTTPS的重定向，来提高性能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-js data-lang=js><span class=nx>Strict</span><span class=o>-</span><span class=nx>Transport</span><span class=o>-</span><span class=nx>Security</span><span class=o>:</span> <span class=nx>max</span><span class=o>-</span><span class=nx>age</span><span class=o>=</span><span class=mi>31536000</span>
</code></pre></td></tr></table></div></div><p>其中，<code>max-age</code>单位为秒。</p><h1 id=checklist>Checklist</h1><ul><li>优化TCP性能</li><li>更新TLS库到最新</li><li>启用配置session cache和session ticket</li><li>监控session cache命中率</li><li>及早结束TLS握手</li><li>配置TLS大小到和MTU匹配</li><li>确保证书链大小不超过<code>cwnd</code></li><li>移除不必要的证书，降低证书深度</li><li>禁用TLS压缩</li><li>配置SNI</li><li>配置OCSP</li><li>增加HSTP header</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>ryji</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-02-14
<a href=https://github.com/ryji/ryji.github.io.git/commit/370dc295fb396c0b359b8ef831573d0987f6aa11 title="add ocsp stapling, hsts">(370dc29)</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/tls/>TLS</a>
<a href=/tags/network/>network</a></div><nav class=post-nav><a class=next href=/post/hpbn-udp/><span class="next-text nav-default">High-Performance Browser Networking 读书笔记-UDP</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:ruoyangji@163.com class="iconfont icon-email" title=email></a><a href=https://github.com/ryji/ class="iconfont icon-github" title=github></a><a href=http://ryji.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>ryji</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],}};</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>