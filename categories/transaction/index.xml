<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>transaction on Clarity</title><link>https://ryji.github.io/categories/transaction/</link><description>Recent content in transaction on Clarity</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Wed, 04 May 2022 18:00:33 +0800</lastBuildDate><atom:link href="https://ryji.github.io/categories/transaction/index.xml" rel="self" type="application/rss+xml"/><item><title>Causal Clock</title><link>https://ryji.github.io/post/csharp/orleans/transaction/orleans_transaction_causalclock/</link><pubDate>Wed, 04 May 2022 18:00:33 +0800</pubDate><guid>https://ryji.github.io/post/csharp/orleans/transaction/orleans_transaction_causalclock/</guid><description>
引言 orleans 项目中，考虑因果性时钟的一种实现。
实现 实现要点 能够保持输出时间的递增性 保证不会因为服务器与NTP服务器同步时间，导致时间戳倒退 代码 1public class CausalClock 2{ 3private readonly object lockable = new object(); 4private readonly IClock clock; 5private long previous; 67public CausalClock(IClock clock) 8{ 9this.clock = clock ?? throw new ArgumentNullException(nameof(clock)); 10} 1112public DateTime UtcNow() 13{ 14lock (this.lockable) 15{ 16// 取最近一次tick + 1 与当前时间的tick的最大值 17var ticks = previous = Math.Max(previous + 1, this.clock.UtcNow().Ticks); 18return new DateTime(ticks, DateTimeKind.Utc); 19} 20} 2122public DateTime Merge(DateTime timestamp) 23{ 24lock (this.</description></item></channel></rss>