<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>network on Clarity</title><link>https://ryji.github.io/tags/network/</link><description>Recent content in network on Clarity</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sat, 13 Feb 2021 15:19:53 +0800</lastBuildDate><atom:link href="https://ryji.github.io/tags/network/index.xml" rel="self" type="application/rss+xml"/><item><title>High-Performance Browser Networking 读书笔记-TLS</title><link>https://ryji.github.io/post/hnbp/hpbn-tls/</link><pubDate>Sat, 13 Feb 2021 15:19:53 +0800</pubDate><guid>https://ryji.github.io/post/hnbp/hpbn-tls/</guid><description>
引言 TLS (Transport Layer Security)建立在传输层之上，为其它协议提供跨网络的安全传输能力，这种能力包含三个部分：加密、认证、防篡改和伪造。TLS通过非对称加密技术，在非加密信道中，为无先验信息的通信双方提供协商会话秘钥(对称秘钥)的方法；在TLS握手过程中，协议规定了一系列认证方法，使通信双方能够互相认证；最后，TLS提供消息校验码(message authentication code，MAC)来对每一条传输的消息进行校验，防止传输途中的篡改和伪造。
HTTP协议的成功，催生出很多网络中间件：缓存服务器、安全网关、内容过滤器等。基于HTTP协议的新协议可能无法被这种中间件识别，或者会被这些中间件盲目地篡改。因此，在WebSocket协议中，一般会推荐使用HTTPS作为其通信的信道，这样防止消息被中间件篡改。
TLS握手 TLS协议握手过程如下图所示：
时刻 事件 0 ms 建立TCP信道 56 ms 客户端发送其支持的TLS信息，包括版本，支持的加密组件列表，随机数rand_c 84 ms 服务端根据客户端发送的信息，选择一种加密组件，附带服务端的证书和随机数rand_s，发送到客户端 112 ms 如果双方对版本和加密方式达成一致，且服务端的证书在客户端认证通过。客户端生成一个对称秘钥key，使用服务端的公钥加密后的发送到服务端，并通知服务端切换到加密传输模式 140 ms 服务端使用私钥解密客户端发送的对称秘钥key，并通过消息的MAC校验消息的完整性。基于对称秘钥key, rand_c, rand_s计算出随后与客户端通信使用的秘钥，并基于此秘钥发送加密的finish消息 168 ms 客户端基于对称秘钥key, rand_c, rand_s计算出对称秘钥，使用此秘钥解密服务端的消息。至此，加密通信信道完全建立 协议扩展 ALPN（Application Layer Protocol Negotiation） 使用自定义协议时，通信的双方需要进行协商，例如http协议升级到2.0。使用ALPN技术，可以利用现有的TLS 443端口协商服务协议，其过程为：客户端在ClientHello消息中增加ProtocolNameList字段，其值为客户端支持的协议列表，服务端读取ProtocolNameList后，根据自身支持的协议，在ServerHello消息中，增加ProtocolName字段，其值为服务端选定的自定义协议。
SNI(server Name Indication) 同一个IP地址host多个不同的服务，每个服务都有各自的TLS证书</description></item><item><title>High-Performance Browser Networking 读书笔记-UDP</title><link>https://ryji.github.io/post/hnbp/hpbn-udp/</link><pubDate>Fri, 12 Feb 2021 12:15:10 +0800</pubDate><guid>https://ryji.github.io/post/hnbp/hpbn-udp/</guid><description>
引言 UDP(User Datagram Protocol)协议，不同于TCP，是一种无连接的不可靠协议。在IP层的基础上，UDP协议增加了四个字段，且其中的port为可选的，checkSum也可以被业务层忽略。因此，UDP协议具有以下特点：
不保证消息送达（没有ACK，重传，timeout） 不保证消息顺序（没有packet编码，没有HOL问题） 无连接（没有连接建立/断开的状态） 无拥塞控制 另外，TCP为面向流的协议，因此，一条消息可能会被分片传输；而UDP协议不会有此情况，一条消息对应一个IP包，不会有分片的问题。
UDP与NAT 为了解决IPV4地址不足的问题，在1994年，人们提出使用NAT(Network Address Translator)设备将内网地址映射到外网地址，这样不同的子网就可以共享内网地址，来解决IPV4地址耗尽的问题。虽然这只是临时的解决方案，但如今NAT已经成为互联网网络基础设施的一部分。
NAT设备维护内部IP、端口与外部IP、端口的映射。TCP协议有明确的连接建立/断开流程，NAT设备可以利用在连接断开时，删除建立的映射关系；然而，UDP协议是无连接的，NAT设备必须维护映射表，处于内网的设备才能接受外部发过来的UDP消息。另外，NAT设备的映射表在没有流量经过一段时间后，会将映射关系置为timeout状态来删除这条映射关系记录。对于UDP应用来说，可以使用双向的keepAlive包来维持NAT设备的映射关系。 另外，虽然理论上NAT设备可以使用TCP连接的状态转移来维护映射关系，但实际上，大多数NAT设备都采用会话超时策略处理UDP和TCP连接。因此，当TCP连接失效时，可能是NAT设备的原因。
STUN, TURN and ICE UDP连接建立时，如果客户端设备隐藏在NAT设备之后，那么必须知道该设备的公网地址才能建立建立，而且，在NAT设备中，必须维护有此公网地址和设备内网地址的映射关系，进入此子网的流量才能经过NAT设备进入目标设备。STUN，TURN和ICE提供了建立端到端UDP连接的方法。
STUN STUN(Session Traversal Utilities for NAT)可以确认应用部署的环境是否存在NAT设备，如果存在NAT设备，则可以获取此连接的外网地址。STUN协议需要使用部署在外网环境的STUN服务器才能完成上述功能。
应用发出一条binding请求到STUN服务器，服务器返回应用的公网IP和端口 应用利用映射的公网IP和端口进行UDP通信 binding请求在请求的路由路径中建立了内外网地址映射关系，使用公网地址的入站流量可以正确地路由到内网地址 STUN协议也定义了一种keepalive的机制，用来维持NAT映射关系防止因超时导致的自动清理 TURN 在部分网络环境下，可能无法通过STUN建立UDP端到端连接。例如，部分企业级网络的防火墙可能禁用UDP协议。在此情况下，可以转用TURN(Traversal Using Relays around NAT)协议。顾名思义，TURN协议依赖公网上的转发来交换peer之间的数据
通信双方都发送allocate请求到同一个TURN服务器，进行通信协商 当协商完成后，通信双方发送数据到TURN服务器，服务器进行数据转发 google libjingle提供了STUN，TURN，ICE协商的能力，而且被使用在google talk等产品中。根据其文档，92%的P2P连接可以直接使用STUN建立，剩余的使用TURN建立
ICE ICE( Interactive Connectivity Establishment)提供了建立高效的P2P通信的方法。优先直接连接，其次考虑使用STUN，在其他方式建立失败后，使用TURN
Checklist 必须适应多种网络环境 应当控制数据传输速率 应当进行拥塞控制 应当与采用与TCP类似的方式使用带宽 应当能够在丢失数据后进行重传 不应当发送大于MTU的数据包 应当处理数据包丢失、重复、乱序 应当能够在2min的延时下保持鲁棒性 应当支持IPV4 UDPcheckSum特性，必须支持IPV6 checkSum 在需要时，可以发送keepalive包(最小间隔不高于15s)</description></item><item><title>High-Performance Browser Networking 读书笔记-TCP</title><link>https://ryji.github.io/post/hnbp/hpbn-tcp/</link><pubDate>Sat, 06 Feb 2021 22:43:58 +0800</pubDate><guid>https://ryji.github.io/post/hnbp/hpbn-tcp/</guid><description>
引言 TCP/IP网络是互联网的核心，IP(Internet Protocal)提供了host-host的路由和寻址协议，TCP(Transmission Control Protocal)协议在不可靠的通信管道上建立了可靠的网络传输，保障接收端接收到的数据和发送端发送的数据内容和顺序一致。虽然协议没有要求，但如今大部分HTTP的实现都建立在TCP协议的基础上。
TCP协议概述 三次握手 TCP协议建立连接时需要进行三次握手，如下表所示
发送端 接收端 SYN (x=rand()) ------&amp;gt; - - &amp;lt;------ SYN ACK (x+1 y=rand()) ACK (y+1 x+1) ------&amp;gt; - 发送端在发送ACK之后就可以向接收端发送业务数据，接收端需要在接收到发送端的ACK之后才能向发送端发送业务数据。如果端到端通信的延时较大(例如：物理距离较远)，那么建立起TCP连接的耗时较长。因此，基于TCP协议的一个常用的优化方式是重用已经建立的连接。
TFO(TCP FAST OPEN, support on Linux 3.7+ kernel)技术可以在SYN packet中发送业务数据，降低部分因三次握手导致的延时。但这种技术只可以应用在部分类型的HTTP请求中，且SYN包中携带的数据包大小也有一定的限制。
拥塞避免和控制 flow control flow control是一种用来避免发送过多的数据导致接收端过载的机制，为了达到这一目的，通信的双方需要在每个ACK包中添加自身的recieve window(rwnd)，使得发送可以根据接收方的rwnd来调整发送速度。当rwnd降为0时，发送端停止向接收端发送数据，直到接收端将自身buffer中的数据处理完毕
最初版本的TCP协议为rwnd分配了16bit的空间，这样限定TCP通信过程中，双方的revieve buffer不能超过$ 2^{16} = 65536 $ bytes。随着应用对数据传输能力要求越来越高，RFC 1323提出 Window Scaling 技术，在ACK packet中将rwnd左移，recieve buffer提高到1G。
slow-start flow-control解决了通信双方不会导致对方过载的问题，但实际上网络中的各个节点处理能力和带宽各有差异。在通信建立时，发送/接收双方无法了解参与通信各个节点的处理能力；随着通信的进行，网络环境发生变化，这时候也需要持续调整数据传输速率来使用网络状况。1988年，Van Jacobson 和 Michael J.</description></item></channel></rss>