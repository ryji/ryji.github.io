<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>csharp on Clarity</title><link>https://example.com/tags/csharp/</link><description>Recent content in csharp on Clarity</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Wed, 04 May 2022 18:00:33 +0800</lastBuildDate><atom:link href="https://example.com/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>Causal Clock</title><link>https://example.com/post/csharp/orleans/transaction/orleans_transaction_causalclock/</link><pubDate>Wed, 04 May 2022 18:00:33 +0800</pubDate><guid>https://example.com/post/csharp/orleans/transaction/orleans_transaction_causalclock/</guid><description>
引言 orleans 项目中，考虑因果性时钟的一种实现。
实现 实现要点 能够保持输出时间的递增性 保证不会因为服务器与NTP服务器同步时间，导致时间戳倒退 代码 1public class CausalClock 2{ 3private readonly object lockable = new object(); 4private readonly IClock clock; 5private long previous; 67public CausalClock(IClock clock) 8{ 9this.clock = clock ?? throw new ArgumentNullException(nameof(clock)); 10} 1112public DateTime UtcNow() 13{ 14lock (this.lockable) 15{ 16// 取最近一次tick + 1 与当前时间的tick的最大值 17var ticks = previous = Math.Max(previous + 1, this.clock.UtcNow().Ticks); 18return new DateTime(ticks, DateTimeKind.Utc); 19} 20} 2122public DateTime Merge(DateTime timestamp) 23{ 24lock (this.</description></item><item><title>C# version golang singleflight</title><link>https://example.com/post/csharp/csharp_singleflight/</link><pubDate>Thu, 25 Jun 2020 15:20:33 +0800</pubDate><guid>https://example.com/post/csharp/csharp_singleflight/</guid><description>
引言 GroupCache 是 go 语言的一个开源项目，其目标提供去中心节点的 P2P 分布式缓存代替 memcached。其中使用到的技术有：LRU cache，一致性哈希，并发请求压缩等。该项目已在 Google 的多个服务中使用。
本文使用 C# 实现 GroupCache 中用到并发请求压缩技术，并使用单元测试验证其功能。
实现 实现要点 需要记录所有执行中的请求，才能在新的请求进来时进行请求压缩，使用字典_onFlight记录；字典_onFlight存在多线程读写问题，需要使用锁来保护； 需要记录请求产生的结果和异常，才能在被阻塞的线程恢复后，将其他线程产生的结果返回到调用方。因此，在OnFlightCallRes添加Res和Exception字段 为了实现请求压缩，需要阻塞/恢复请求，且阻塞/恢复的单位是每一个同key的请求。使用ManualResetEventSlim进行线程的阻塞/恢复。因为阻塞/恢复的单元和执行结果都以key作为主键，将此变量放入OnFlightCallRes中 代码 1public class SingleFlight 2{ 3/// &amp;lt;summary&amp;gt; 4/// Keep Key After Execute Call 5/// &amp;lt;/summary&amp;gt; 6private readonly bool _keepKey; 78/// &amp;lt;summary&amp;gt; 9/// dic to store call result 10/// &amp;lt;/summary&amp;gt; 11private readonly Dictionary&amp;lt;string, OnFlightCallRes&amp;gt; _onFlight; 1213/// &amp;lt;summary&amp;gt; 14/// lock 15/// &amp;lt;/summary&amp;gt; 16private readonly ReaderWriterLockSlim _lockSlim; 1718public SingleFlight(bool keepKey) 19{ 20_keepKey = keepKey; 21_onFlight = new Dictionary&amp;lt;string, OnFlightCallRes&amp;gt;(); 22_lockSlim = new ReaderWriterLockSlim(); 23} 2425/// &amp;lt;summary&amp;gt; 26/// Return &amp;lt;paramref name=&amp;#34;callFunc&amp;#34;/&amp;gt; Result 27/// calls from different thread with the same &amp;lt;paramref name=&amp;#34;key&amp;#34;/&amp;gt; will be compressed to one call 28/// &amp;lt;/summary&amp;gt; 29/// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;&amp;lt;/typeparam&amp;gt; 30/// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; 31/// &amp;lt;param name=&amp;#34;callFunc&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; 32/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; 33public T Call&amp;lt;T&amp;gt;(string key, Func&amp;lt;T&amp;gt; callFunc) 34{ 35_lockSlim.</description></item><item><title>Template in C#</title><link>https://example.com/post/csharp/template_in_csharp/</link><pubDate>Mon, 05 Mar 2018 05:43:58 +0800</pubDate><guid>https://example.com/post/csharp/template_in_csharp/</guid><description>
引言 泛型（参数化类型），将程序逻辑从具体的类型中分离出来，从而提高代码的复用性。 .Net的System.Collections.Generic命名空间中定义的大多数类型使用了泛型技术，比如List&amp;lt;T&amp;gt;，Stack&amp;lt;T&amp;gt;，Tuple&amp;lt;T1, T2, T3, ...&amp;gt;，SortedList&amp;lt;TKey, TValue&amp;gt;等，另外，委托类型也提供了泛型委托Action和Function。泛型接口定义了一种参数化类型的接口，保障程序的类型安全。
泛型树节点接口 以树的遍历为例，不管树节点的类型和实现是什么，只要知道当前节点的深度和其子节点，就可以进行树的遍历。因此，定义泛型树节点接口ITreeNode&amp;lt;T&amp;gt;。
1public interface ITreeNode&amp;lt;T&amp;gt; where T : class 2{ 3int Depth { get; set; } //深度 4List&amp;lt;T&amp;gt; GetChildren(); //获取子节点 5} 泛型树的约束 在泛型树的定义中添加约束class和ITreeNode&amp;lt;T&amp;gt;，这样，在编译期就可以确保类型安全，用未实现ITreeNode&amp;lt;T&amp;gt;接口的class来实例化Tree&amp;lt;T&amp;gt;时会编译出错。
1public class Tree&amp;lt;T&amp;gt; where T : class, ITreeNode&amp;lt;T&amp;gt; 2{ 3//树根 4public T Root { get; set; } 5//最大深度 6public int MaxDepth { get; set; } 78public void Travel() 9{ 10Travel(Root, MaxDepth); 11} 1213public void Travel(int maxDepth) 14{ 15Debug.Assert(maxDepth &amp;gt;= 0); 16Travel(Root, Math.</description></item></channel></rss>