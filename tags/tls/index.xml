<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TLS on Clarity</title><link>https://example.com/tags/tls/</link><description>Recent content in TLS on Clarity</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sat, 13 Feb 2021 15:19:53 +0800</lastBuildDate><atom:link href="https://example.com/tags/tls/index.xml" rel="self" type="application/rss+xml"/><item><title>High-Performance Browser Networking 读书笔记-TLS</title><link>https://example.com/post/hnbp/hpbn-tls/</link><pubDate>Sat, 13 Feb 2021 15:19:53 +0800</pubDate><guid>https://example.com/post/hnbp/hpbn-tls/</guid><description>
引言 TLS (Transport Layer Security)建立在传输层之上，为其它协议提供跨网络的安全传输能力，这种能力包含三个部分：加密、认证、防篡改和伪造。TLS通过非对称加密技术，在非加密信道中，为无先验信息的通信双方提供协商会话秘钥(对称秘钥)的方法；在TLS握手过程中，协议规定了一系列认证方法，使通信双方能够互相认证；最后，TLS提供消息校验码(message authentication code，MAC)来对每一条传输的消息进行校验，防止传输途中的篡改和伪造。
HTTP协议的成功，催生出很多网络中间件：缓存服务器、安全网关、内容过滤器等。基于HTTP协议的新协议可能无法被这种中间件识别，或者会被这些中间件盲目地篡改。因此，在WebSocket协议中，一般会推荐使用HTTPS作为其通信的信道，这样防止消息被中间件篡改。
TLS握手 TLS协议握手过程如下图所示：
时刻 事件 0 ms 建立TCP信道 56 ms 客户端发送其支持的TLS信息，包括版本，支持的加密组件列表，随机数rand_c 84 ms 服务端根据客户端发送的信息，选择一种加密组件，附带服务端的证书和随机数rand_s，发送到客户端 112 ms 如果双方对版本和加密方式达成一致，且服务端的证书在客户端认证通过。客户端生成一个对称秘钥key，使用服务端的公钥加密后的发送到服务端，并通知服务端切换到加密传输模式 140 ms 服务端使用私钥解密客户端发送的对称秘钥key，并通过消息的MAC校验消息的完整性。基于对称秘钥key, rand_c, rand_s计算出随后与客户端通信使用的秘钥，并基于此秘钥发送加密的finish消息 168 ms 客户端基于对称秘钥key, rand_c, rand_s计算出对称秘钥，使用此秘钥解密服务端的消息。至此，加密通信信道完全建立 协议扩展 ALPN（Application Layer Protocol Negotiation） 使用自定义协议时，通信的双方需要进行协商，例如http协议升级到2.0。使用ALPN技术，可以利用现有的TLS 443端口协商服务协议，其过程为：客户端在ClientHello消息中增加ProtocolNameList字段，其值为客户端支持的协议列表，服务端读取ProtocolNameList后，根据自身支持的协议，在ServerHello消息中，增加ProtocolName字段，其值为服务端选定的自定义协议。
SNI(server Name Indication) 同一个IP地址host多个不同的服务，每个服务都有各自的TLS证书</description></item></channel></rss>