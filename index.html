<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.79.1"><meta name=viewport content="width=device-width,initial-scale=1"><title>My New Hugo Site</title><meta name=description content><link type=text/css rel=stylesheet href=http://example.org/css/print.css media=print><link type=text/css rel=stylesheet href=http://example.org/css/poole.css><link type=text/css rel=stylesheet href=http://example.org/css/syntax.css><link type=text/css rel=stylesheet href=http://example.org/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=http://example.org/index.xml rel=alternate type=application/rss+xml title="My New Hugo Site"></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=http://example.org/><h1>My New Hugo Site</h1></a><p class=lead>An elegant open source and mobile first theme for <a href=http://hugo.spf13.com>hugo</a> made by <a href=http://twitter.com/mdo>@mdo</a>. Originally made for Jekyll.</p></div><nav><ul class=sidebar-nav><li><a href=http://example.org/>Home</a></li></ul></nav><p>&copy; 2021. All rights reserved.</p></div></aside><main class="content container"><div class=posts><article class=post><h1 class=post-title><a href=http://example.org/post/template_in_csharp/>Template in C#</a></h1><time datetime=2018-03-05T05:43:58+0800 class=post-date>Mon, Mar 5, 2018</time>
泛型（参数化类型），将程序逻辑从具体的类型中分离出来，从而提高代码的复用性。 .Net的System.Collections.Generic命名空间中定义的大多数类型使用了泛型技术，比如List&lt;T>，Stack&lt;T>，Tuple&lt;T1, T2, T3, ...>，SortedList&lt;TKey, TValue>等，另外，委托类型也提供了泛型委托Action和Function。泛型接口定义了一种参数化类型的接口，保障程序的类型安全。
泛型树节点接口 以树的遍历为例，不管树节点的类型和实现是什么，只要知道当前节点的深度和其子节点，就可以进行树的遍历。因此，定义泛型树节点接口ITreeNode&lt;T>。
public interface ITreeNode&lt;T> where T : class { int Depth { get; set; } //深度 List&lt;T> GetChildren(); //获取子节点 } 泛型树的约束 在泛型树的定义中添加约束class和ITreeNode&lt;T>，这样，在编译期就可以确保类型安全，用未实现ITreeNode&lt;T>接口的class来实例化Tree&lt;T>时会编译出错。
public class Tree&lt;T> where T : class, ITreeNode&lt;T> { //树根 public T Root { get; set; } //最大深度 public int MaxDepth { get; set; } public void Travel() { Travel(Root, MaxDepth); } public void Travel(int maxDepth) { Debug.Assert(maxDepth >= 0); Travel(Root, Math.<div class=read-more-link><a href=/post/template_in_csharp/>Read More…</a></div></article></div></main></body></html>